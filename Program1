First, we created a register class as the register in the simulator. This class sets the overflow judgment. Then, we define memory as a dictionary and implement its load and store functions directly in the function. In the instruction class, we do the decoder here. Opcode, gprIndex, ixrIndex, indirect are computed for this class. 
Next, implement creating threads, loading and storing memory, and calculating EA in the ISAImplementation class. 
The ISAImplementation class is a large class where all simulation calculations are performed. First, we'll create a new in-memory entity here, along with corresponding registered entities such as GPRS and ixrs. First, we initialize all registers and memory. Additionally, we will have functions to simulate "fetch" and functions to simulate "execute" using MAR, MBR, IR, and PC and functions. This function combines the control unit and instruction decoder on the physical chip. In this class, the run function will start the machine. And the effective address will be calculated according to the logic given by the specification. 
Finally, determine the stop command to get LDR, STR, LDA, LDX, STX. 
The Main GUI class has input widgets for hexadecimal and binary values. This is where you load the program to start implementing it. Inputs can be loaded into your choice of GPR registers, IXR registers, PC, MAR, MBR, IR, and CC.
Debug GUI class allows the user to set the CPU speed, print or flush cache, load, or store addresses or content. It also prints out console output with the instructions and contents and mentions whether the cache was hit or missed.
The I/O GUI class allows the user to enter a value on the console, and it reads the entered number one at a time. The print will output results based on the values you enter.
